# CS-340
Client/Server Development

**How do you write programs that are maintainable, readable, and adaptable? Especially consider your work on the CRUD Python module from Project One, which you used to connect the dashboard widgets to the database in Project Two. What were the advantages of working in this way? How else could you use this CRUD Python module in the future?**

These principles are essential to any software development project, and I'm glad that schooling has drilled that into me. Writing programs to fit this criteria starts mostly with how you plan and approach. Modularity is key, and designing small, single use modules will do wonders for keeping programs adaptable. As well, following best practices, standards, and style guide set down by you client or team will ensure that code stays readable. Comment often with clear, concise comments, but not so often to be distracting. The CRUD module is a good example. It is, with minor tweaking, built to be used with any MongoDB database. Some slight work to make connection to the server more adaptable would be needed, but that would be a relatively easy fix. Once that happened, you only had to pass through your parameters for your specific MongoDB instance, and the CRUD module would work without issue. 

**How do you approach a problem as a computer scientist? Consider how you approached the database or dashboard requirements that Grazioso Salvare requested. How did your approach to this project differ from previous assignments in other courses? What techniques or strategies would you use in the future to create databases to meet other client requests?**

I approach problems first by carefully reviewing the requirements. Understanding those is key to building software that fits the intended purpose. I then come up with a plan, and ask myself what do I know how to fix, and what do I not? If there are areas where I need to do some research, I seek them out. Then, I decide how to make a modular, efficient program and begin work on my plan little piece by little piece. This way, problems are never more than I can manage and I will have software ready sooner rather than later. My approach for this project wasn't any different. There was a lot I had to study and research in order to understand, but otherwise I approached it as I would any other project. The skills I learned were a fantastic set of building blocks. I should be able to adapt them with little tweaking directly to another MongoDB project to build out any database that might be required.

**What do computer scientists do, and why does it matter? How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?**

Starting into this degree, I might have thought computer scientists were mainly coders. That was, after all, the main appeal of the degree. Without a doubt, that is a large part of their role. However, a computer scientist, I have learned, is more focused on how to _design_ a program than the actual making of it. Where the value of a good computer scientist comes into play lies in the ability to plan and implement modular, safe, responsible, maintanable, expandable code. Any code monkey can cobble together a whole slew of bandaids in order to make a system work generally as the client wants. I've worked for companies with systems like that. The problem with this is that in the end, while it might initially be a cheaper or "easier" option, the system will become incapable of growing to meet new demands. In the end, a system that is not designed to change and adapt will cost much much more for either extensive rewrites and re-bandaiding, or a completely new system overhaul. If the principles of good computer science are implemented, these issues can be avoided with a bit more work upfront. As an added bonus, if a program is well designed, future development should be quicker, easier, and more efficient. In the end, a good computer science can save a company immeasurable amounts of time, money, heartach, and in some cases reputation.
